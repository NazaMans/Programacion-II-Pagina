<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <title>Teoria de plantillas estandar</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <header>
        <h1>Plantillas estandar (Vector, lista, stack, etc)</h1>
        <nav>
            <a href="../index.html">Volver al Índice Principal</a>
        </nav>
    </header>

    <main>
        <section>
            <h2>Introducción a la Biblioteca de Plantillas Estándar (STL)</h2>
            <p>La Biblioteca de Plantillas Estándar (Standard Template Library, STL) es un conjunto de clases y funciones genéricas de C++ que proporcionan estructuras de datos y algoritmos de propósito general. Es una parte integral de la biblioteca estándar de C++ y facilita enormemente el desarrollo de software al ofrecer componentes robustos y eficientes ya implementados.</p>
            <p>La STL se basa en el concepto de <strong>programación genérica</strong>, utilizando plantillas para que los algoritmos y estructuras de datos funcionen con cualquier tipo de dato, sin necesidad de reescribir el código para cada tipo.</p>
        </section>

        <section>
            <h2>Componentes Principales de la STL</h2>
            <p>La STL se organiza en cuatro componentes principales interrelacionados:</p>
            <ul>
                <li><strong>Contenedores:</strong> Estructuras de datos que almacenan colecciones de objetos.</li>
                <li><strong>Algoritmos:</strong> Funciones que realizan operaciones comunes sobre los datos almacenados en los contenedores.</li>
                <li><strong>Iteradores:</strong> Actúan como punteros, proporcionando una forma uniforme de acceder a los elementos de los contenedores.</li>
                <li><strong>Functores (Objetos de Función):</strong> Objetos que pueden ser invocados como si fueran funciones.</li>
            </ul>
            </section>

        <section>
            <h2>Contenedores</h2>
            <p>Los contenedores STL son estructuras de datos que almacenan objetos de manera organizada. Se clasifican principalmente en:</p>

            <h3>Contenedores Secuenciales:</h3>
            <p>Almacenan elementos en un orden lineal, permitiendo acceso secuencial. El orden de los elementos depende del orden de inserción.</p>
            <ul>
                <li>
                    <strong>`std::vector` (Vector Dinámico):</strong>
                    <p>Un array dinámico que puede crecer o encogerse según sea necesario. Ofrece acceso aleatorio a elementos (`O(1)`) y es muy eficiente para añadir elementos al final. Inserciones o eliminaciones en el medio pueden ser costosas (`O(n)`).</p>
                    <pre><code class="language-cpp">
#include <vector>
// ...
std::vector<int> numeros = {1, 2, 3};
numeros.push_back(4); // Añadir al final
int primer = numeros[0];
// Acceso directo
                    </code></pre>
                </li>
                <li>
                    <strong>`std::list` (Lista Doblemente Enlazada):</strong>
                    <p>Elementos no contiguos en memoria, enlazados bidireccionalmente. Eficiente para inserciones y eliminaciones en cualquier posición (`O(1)`), pero el acceso a elementos es secuencial (`O(n)`).</p>
                    <pre><code class="language-cpp">
#include <list>
// ...
std::list<std::string> nombres;
nombres.push_back("Alice");
nombres.push_front("Bob");
                    </code></pre>
                </li>
                <li>
                    <strong>`std::deque` (Cola de Doble Extremo):</strong>
                    <p>Permite inserciones y eliminaciones eficientes tanto al principio como al final (`O(1)`), y acceso aleatorio. Utiliza un conjunto de bloques de memoria.</p>
                    <pre><code class="language-cpp">
#include <deque>
// ...
std::deque<char> letras;
letras.push_front('A');
letras.push_back('Z');
                    </code></pre>
                </li>
            </ul>

            <h3>Contenedores Asociativos:</h3>
            <p>Almacenan elementos ordenados según un criterio de clave. Permiten búsquedas, inserciones y eliminaciones eficientes basándose en la clave (`O(log n)`).</p>
            <ul>
                <li>
                    <strong>`std::map` (Mapa Clave-Valor):</strong>
                    <p>Almacena pares clave-valor, donde las claves son únicas y están ordenadas. Cada clave mapea a un único valor. Similar a un diccionario.</p>
                    <pre><code class="language-cpp">
#include <map>
// ...
std::map<std::string, int> edades;
edades["Juan"] = 30;
edades["Maria"] = 25;
int edadJuan = edades["Juan"];
                    </code></pre>
                </li>
                <li>
                    <strong>`std::set` (Conjunto Ordenado):</strong>
                    <p>Almacena un conjunto de elementos únicos, ordenados según un criterio. Útil para verificar la existencia de un elemento rápidamente.</p>
                    <pre><code class="language-cpp">
#include <set>
// ...
std::set<int> numerosUnicos;
numerosUnicos.insert(10);
numerosUnicos.insert(5);
bool existe = numerosUnicos.count(10); // true
                    </code></pre>
                </li>
                </ul>

            <h3>Contenedores Adaptadores:</h3>
            <p>No son contenedores en sí mismos, sino que proporcionan interfaces específicas usando otros contenedores como base.</p>
            <ul>
                <li>
                    <strong>`std::stack` (Pila):</strong>
                    <p>Implementa la estructura de datos LIFO (Last-In, First-Out). Métodos: `push`, `pop`, `top`, `empty`.</p>
                    <pre><code class="language-cpp">
#include <stack>
// ...
std::stack<int> miPila;
miPila.push(10);
int cima = miPila.top(); // 10
miPila.pop();
                    </code></pre>
                </li>
                <li>
                    <strong>`std::queue` (Cola):</strong>
                    <p>Implementa la estructura de datos FIFO (First-In, First-Out). Métodos: `push`, `pop`, `front`, `back`, `empty`.</p>
                    <pre><code class="language-cpp">
#include <queue>
// ...
std::queue<std::string> miCola;
miCola.push("Tarea1");
std::string frente = miCola.front(); // Tarea1
miCola.pop();
                    </code></pre>
                </li>
            </ul>
        </section>

        <section>
            <h2>Algoritmos</h2>
            <p>Los algoritmos STL son funciones genéricas que operan sobre rangos de elementos definidos por iteradores. Se encuentran en el encabezado `<algorithm>`. Son independientes del tipo de contenedor, lo que los hace muy versátiles.</p>
            <ul>
                <li>
                    <strong>`std::sort` (Ordenar):</strong>
                    <p>Ordena los elementos en un rango especificado.</p>
                    <pre><code class="language-cpp">
#include <algorithm>
#include <vector>
// ...
std::vector<int> v = {5, 2, 8, 1};
std::sort(v.begin(), v.end()); // v será {1, 2, 5, 8}
                    </code></pre>
                </li>
                <li>
                    <strong>`std::find` (Buscar):</strong>
                    <p>Busca un valor específico en un rango y retorna un iterador al primer elemento encontrado (o `end()` si no se encuentra).</p>
                    <pre><code class="language-cpp">
#include <algorithm>
#include <vector>
// ...
std::vector<int> v = {10, 20, 30, 40};
auto it = std::find(v.begin(), v.end(), 30);
if (it != v.end()) {
    // Se encontró el 30
}
                    </code></pre>
                </li>
                <li>
                    <strong>`std::for_each` (Para Cada Elemento):</strong>
                    <p>Aplica una función o un funtor a cada elemento en un rango.</p>
                    <pre><code class="language-cpp">
#include <algorithm>
#include <vector>
#include <iostream>
// ...
std::vector<int> v = {1, 2, 3};
std::for_each(v.begin(), v.end(), [](int n){ std::cout << n * 2 << " "; });
// Imprime: 2 4 6
                    </code></pre>
                </li>
                <li>
                    <strong>`std::count` (Contar Ocurrencias):</strong>
                    <p>Cuenta el número de veces que un valor aparece en un rango.</p>
                    <pre><code class="language-cpp">
#include <algorithm>
#include <vector>
// ...
std::vector<int> v = {1, 2, 2, 3, 2};
int conteo = std::count(v.begin(), v.end(), 2);
// conteo será 3
                    </code></pre>
                </li>
            </ul>
        </section>

        <section>
            <h2>Iteradores</h2>
            <p>Los iteradores son objetos que proporcionan una forma unificada de acceder a los elementos de cualquier contenedor STL. Actúan como punteros genéricos, permitiendo recorrer la colección y acceder a sus elementos.</p>
            <ul>
                <li>Cada contenedor tiene métodos `begin()` (retorna un iterador al primer elemento) y `end()` (retorna un iterador al "pasado-el-último" elemento).</li>
                <li>Los iteradores se pueden incrementar (`++`) para moverse al siguiente elemento y desreferenciar (`*`) para acceder al valor.</li>
            </ul>
            <pre><code class="language-cpp">
#include <vector>
#include <iostream>
// ...
std::vector<int> nums = {10, 20, 30};
for (std::vector<int>::iterator it = nums.begin(); it != nums.end(); ++it) {
    std::cout << *it << " ";
// Imprime: 10 20 30
}
            </code></pre>
        </section>

        <section>
            <h2>Functores (Objetos de Función)</h2>
            <p>Un funtor es cualquier objeto que puede ser llamado o "invocado" como si fuera una función. Esto se logra sobrecargando el operador paréntesis `operator()`. Los functores son muy utilizados con los algoritmos STL para proporcionar comportamientos personalizados.</p>
            <p>La STL también proporciona una serie de functores predefinidos en el encabezado `<functional>` para operaciones aritméticas, relacionales y lógicas.</p>
            <pre><code class="language-cpp">
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional> // Para functores predefinidos

// Funtor personalizado para duplicar
struct Duplicar {
    void operator()(int& n) const {
        n *= 2;
}
};

// ...
std::vector<int> v = {1, 2, 3};
std::for_each(v.begin(), v.end(), Duplicar());
// Usa el funtor Duplicar
// v será {2, 4, 6}

// Ejemplo con funtor predefinido
std::vector<int> v2 = {10, 20, 30};
std::sort(v2.begin(), v2.end(), std::greater<int>()); // Ordena de mayor a menor
// v2 será {30, 20, 10}
            </code></pre>
            <p>Los functores predefinidos más comunes incluyen:</p>
            <ul>
                <li><strong>Aritméticos:</strong> `std::plus`, `std::minus`, `std::multiplies`, etc.</li>
                <li><strong>Relacionales:</strong> `std::equal_to`, `std::less`, `std::greater`, etc.</li>
                <li><strong>Lógicos:</strong> `std::logical_and`, `std::logical_or`, `std::logical_not`.</li>
            </ul>
        </section>

        <section>
    <h2>Algoritmos de la STL</h2>
    <p>
        Los algoritmos en la STL son funciones que operan sobre contenedores, proporcionando operaciones útiles como búsqueda, ordenación, modificación y más.
    </p>
    <ul>
        <li><code>std::sort</code>: Ordena los elementos de un contenedor.</li>
        <li><code>std::find</code>: Busca un elemento en un rango de un contenedor.</li>
        <li><code>std::reverse</code>: Invierte el orden de los elementos en un rango.</li>
        <li><code>std::count</code>: Cuenta el número de ocurrencias de un valor en un rango.</li>
        <li><code>std::accumulate</code> (de la librería <code>&lt;numeric&gt;</code>): Suma los elementos de un rango.</li>
        <li><code>std::for_each</code>: Aplica una función a cada elemento en un rango.</li>
        <li><code>std::remove_if</code>: Elimina elementos que cumplen una condición específica.</li>
        <li><code>std::transform</code>: Aplica una función a un rango y guarda el resultado en otro rango.</li>
    </ul>

    <h3>Ejemplos de uso</h3>
    <pre><code>// Ordena el vector `vec` en orden ascendente
std::sort(vec.begin(), vec.end());

// Busca `valor` en el vector `vec`
std::find(vec.begin(), vec.end(), valor);

// Invierte la lista `list`
std::reverse(list.begin(), list.end());

// Cuenta las ocurrencias de `valor` en `vec`
std::count(vec.begin(), vec.end(), valor);

// Suma todos los elementos de `vec`, comenzando desde 0
std::accumulate(vec.begin(), vec.end(), 0);

// Multiplica cada elemento de `vec` por 2
void multiplicarPorDos(int& n) { n *= 2; }
std::for_each(vec.begin(), vec.end(), multiplicarPorDos);

// Elimina números pares de `vec`
bool esPar(int n) { return n % 2 == 0; }
std::remove_if(vec.begin(), vec.end(), esPar);

// Eleva al cuadrado cada elemento de `vec`
int elevarAlCuadrado(int n) { return n * n; }
std::transform(vec.begin(), vec.end(), vec.begin(), elevarAlCuadrado);
    </code></pre>
</section>

        
        <section class="navegacion-modulo">
            <p>Practica</p>
            <a href="practica.html" class="boton-practica">Ir a la Práctica del modulo</a>
        </section>
    </main>

    <footer>
        <p>Volver al <a href="../index.html">Índice Principal</a></p>
    </footer>
</body>
</html>