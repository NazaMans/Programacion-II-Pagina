<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <title>Módulo 6: STL - Teoría</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <header>
        <h1>Módulo 6: Biblioteca de Plantillas Estándar (STL)</h1>
        <nav>
            <a href="../index.html">Volver al Índice Principal</a>
        </nav>
    </header>

    <main>
        <section>
            <h2>Introducción a la Biblioteca de Plantillas Estándar (STL)</h2>
            <p>La Biblioteca de Plantillas Estándar (Standard Template Library, STL) es un conjunto de clases y funciones genéricas de C++ que proporcionan estructuras de datos y algoritmos de propósito general. Es una parte integral de la biblioteca estándar de C++ y facilita enormemente el desarrollo de software al ofrecer componentes robustos y eficientes ya implementados.</p>
            <p>La STL se basa en el concepto de <strong>programación genérica</strong>, utilizando plantillas para que los algoritmos y estructuras de datos funcionen con cualquier tipo de dato, sin necesidad de reescribir el código para cada tipo.</p>
        </section>

        <section>
            <h2>Componentes Principales de la STL</h2>
            <p>La STL se organiza en cuatro componentes principales interrelacionados:</p>
            <ul>
                <li><strong>Contenedores:</strong> Estructuras de datos que almacenan colecciones de objetos.</li>
                <li><strong>Algoritmos:</strong> Funciones que realizan operaciones comunes sobre los datos almacenados en los contenedores.</li>
                <li><strong>Iteradores:</strong> Actúan como punteros, proporcionando una forma uniforme de acceder a los elementos de los contenedores.</li>
                <li><strong>Functores (Objetos de Función):</strong> Objetos que pueden ser invocados como si fueran funciones.</li>
            </ul>
            </section>

        <section>
            <h2>Contenedores</h2>
            <p>Los contenedores STL son estructuras de datos que almacenan objetos de manera organizada. Se clasifican principalmente en:</p>

            <h3>Contenedores Secuenciales:</h3>
            <p>Almacenan elementos en un orden lineal, permitiendo acceso secuencial. El orden de los elementos depende del orden de inserción.</p>
            <ul>
                <li>
                    <strong>`std::vector` (Vector Dinámico):</strong>
                    <p>Un array dinámico que puede crecer o encogerse según sea necesario. Ofrece acceso aleatorio a elementos (`O(1)`) y es muy eficiente para añadir elementos al final. Inserciones o eliminaciones en el medio pueden ser costosas (`O(n)`).</p>
                    <pre><code class="language-cpp">
#include &lt;vector&gt;
// ...
std::vector&lt;int&gt; numeros = {1, 2, 3};
numeros.push_back(4); // Añadir al final
int primer = numeros[0]; // Acceso directo
                    </code></pre>
                </li>
                <li>
                    <strong>`std::list` (Lista Doblemente Enlazada):</strong>
                    <p>Elementos no contiguos en memoria, enlazados bidireccionalmente. Eficiente para inserciones y eliminaciones en cualquier posición (`O(1)`), pero el acceso a elementos es secuencial (`O(n)`).</p>
                    <pre><code class="language-cpp">
#include &lt;list&gt;
// ...
std::list&lt;std::string&gt; nombres;
nombres.push_back("Alice");
nombres.push_front("Bob");
                    </code></pre>
                </li>
                <li>
                    <strong>`std::deque` (Cola de Doble Extremo):</strong>
                    <p>Permite inserciones y eliminaciones eficientes tanto al principio como al final (`O(1)`), y acceso aleatorio. Utiliza un conjunto de bloques de memoria.</p>
                    <pre><code class="language-cpp">
#include &lt;deque&gt;
// ...
std::deque&lt;char&gt; letras;
letras.push_front('A');
letras.push_back('Z');
                    </code></pre>
                </li>
            </ul>

            <h3>Contenedores Asociativos:</h3>
            <p>Almacenan elementos ordenados según un criterio de clave. Permiten búsquedas, inserciones y eliminaciones eficientes basándose en la clave (`O(log n)`).</p>
            <ul>
                <li>
                    <strong>`std::map` (Mapa Clave-Valor):</strong>
                    <p>Almacena pares clave-valor, donde las claves son únicas y están ordenadas. Cada clave mapea a un único valor. Similar a un diccionario.</p>
                    <pre><code class="language-cpp">
#include &lt;map&gt;
// ...
std::map&lt;std::string, int&gt; edades;
edades["Juan"] = 30;
edades["Maria"] = 25;
int edadJuan = edades["Juan"];
                    </code></pre>
                </li>
                <li>
                    <strong>`std::set` (Conjunto Ordenado):</strong>
                    <p>Almacena un conjunto de elementos únicos, ordenados según un criterio. Útil para verificar la existencia de un elemento rápidamente.</p>
                    <pre><code class="language-cpp">
#include &lt;set&gt;
// ...
std::set&lt;int&gt; numerosUnicos;
numerosUnicos.insert(10);
numerosUnicos.insert(5);
bool existe = numerosUnicos.count(10); // true
                    </code></pre>
                </li>
                </ul>

            <h3>Contenedores Adaptadores:</h3>
            <p>No son contenedores en sí mismos, sino que proporcionan interfaces específicas usando otros contenedores como base.</p>
            <ul>
                <li>
                    <strong>`std::stack` (Pila):</strong>
                    <p>Implementa la estructura de datos LIFO (Last-In, First-Out). Métodos: `push`, `pop`, `top`, `empty`.</p>
                    <pre><code class="language-cpp">
#include &lt;stack&gt;
// ...
std::stack&lt;int&gt; miPila;
miPila.push(10);
int cima = miPila.top(); // 10
miPila.pop();
                    </code></pre>
                </li>
                <li>
                    <strong>`std::queue` (Cola):</strong>
                    <p>Implementa la estructura de datos FIFO (First-In, First-Out). Métodos: `push`, `pop`, `front`, `back`, `empty`.</p>
                    <pre><code class="language-cpp">
#include &lt;queue&gt;
// ...
std::queue&lt;std::string&gt; miCola;
miCola.push("Tarea1");
std::string frente = miCola.front(); // Tarea1
miCola.pop();
                    </code></pre>
                </li>
            </ul>
        </section>

        <section>
            <h2>Algoritmos</h2>
            <p>Los algoritmos STL son funciones genéricas que operan sobre rangos de elementos definidos por iteradores. Se encuentran en el encabezado `<algorithm>`. Son independientes del tipo de contenedor, lo que los hace muy versátiles.</p>
            <ul>
                <li>
                    <strong>`std::sort` (Ordenar):</strong>
                    <p>Ordena los elementos en un rango especificado.</p>
                    <pre><code class="language-cpp">
#include &lt;algorithm&gt;
#include &lt;vector&gt;
// ...
std::vector&lt;int&gt; v = {5, 2, 8, 1};
std::sort(v.begin(), v.end()); // v será {1, 2, 5, 8}
                    </code></pre>
                </li>
                <li>
                    <strong>`std::find` (Buscar):</strong>
                    <p>Busca un valor específico en un rango y retorna un iterador al primer elemento encontrado (o `end()` si no se encuentra).</p>
                    <pre><code class="language-cpp">
#include &lt;algorithm&gt;
#include &lt;vector&gt;
// ...
std::vector&lt;int&gt; v = {10, 20, 30, 40};
auto it = std::find(v.begin(), v.end(), 30);
if (it != v.end()) {
    // Se encontró el 30
}
                    </code></pre>
                </li>
                <li>
                    <strong>`std::for_each` (Para Cada Elemento):</strong>
                    <p>Aplica una función o un funtor a cada elemento en un rango.</p>
                    <pre><code class="language-cpp">
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
// ...
std::vector&lt;int&gt; v = {1, 2, 3};
std::for_each(v.begin(), v.end(), [](int n){ std::cout << n * 2 << " "; }); // Imprime: 2 4 6
                    </code></pre>
                </li>
                <li>
                    <strong>`std::count` (Contar Ocurrencias):</strong>
                    <p>Cuenta el número de veces que un valor aparece en un rango.</p>
                    <pre><code class="language-cpp">
#include &lt;algorithm&gt;
#include &lt;vector&gt;
// ...
std::vector&lt;int&gt; v = {1, 2, 2, 3, 2};
int conteo = std::count(v.begin(), v.end(), 2); // conteo será 3
                    </code></pre>
                </li>
            </ul>
        </section>

        <section>
            <h2>Iteradores</h2>
            <p>Los iteradores son objetos que proporcionan una forma unificada de acceder a los elementos de cualquier contenedor STL. Actúan como punteros genéricos, permitiendo recorrer la colección y acceder a sus elementos.</p>
            <ul>
                <li>Cada contenedor tiene métodos `begin()` (retorna un iterador al primer elemento) y `end()` (retorna un iterador al "pasado-el-último" elemento).</li>
                <li>Los iteradores se pueden incrementar (`++`) para moverse al siguiente elemento y desreferenciar (`*`) para acceder al valor.</li>
            </ul>
            <pre><code class="language-cpp">
#include &lt;vector&gt;
#include &lt;iostream&gt;
// ...
std::vector&lt;int&gt; nums = {10, 20, 30};
for (std::vector&lt;int&gt;::iterator it = nums.begin(); it != nums.end(); ++it) {
    std::cout << *it << " "; // Imprime: 10 20 30
}
            </code></pre>
        </section>

        <section>
            <h2>Functores (Objetos de Función)</h2>
            <p>Un funtor es cualquier objeto que puede ser llamado o "invocado" como si fuera una función. Esto se logra sobrecargando el operador paréntesis `operator()`. Los functores son muy utilizados con los algoritmos STL para proporcionar comportamientos personalizados.</p>
            <p>La STL también proporciona una serie de functores predefinidos en el encabezado `<functional>` para operaciones aritméticas, relacionales y lógicas.</p>
            <pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt; // Para functores predefinidos

// Funtor personalizado para duplicar
struct Duplicar {
    void operator()(int& n) const {
        n *= 2;
    }
};

// ...
std::vector&lt;int&gt; v = {1, 2, 3};
std::for_each(v.begin(), v.end(), Duplicar()); // Usa el funtor Duplicar
// v será {2, 4, 6}

// Ejemplo con funtor predefinido
std::vector&lt;int&gt; v2 = {10, 20, 30};
std::sort(v2.begin(), v2.end(), std::greater&lt;int&gt;()); // Ordena de mayor a menor
// v2 será {30, 20, 10}
            </code></pre>
            <p>Los functores predefinidos más comunes incluyen:</p>
            <ul>
                <li><strong>Aritméticos:</strong> `std::plus`, `std::minus`, `std::multiplies`, etc.</li>
                <li><strong>Relacionales:</strong> `std::equal_to`, `std::less`, `std::greater`, etc.</li>
                <li><strong>Lógicos:</strong> `std::logical_and`, `std::logical_or`, `std::logical_not`.</li>
            </ul>
        </section>
        
        <section class="navegacion-modulo">
            <p>¡Prepárate para usar las herramientas más poderosas de C++!</p>
            <a href="practica.html" class="boton-practica">Ir a la Práctica del Módulo 6</a>
        </section>
    </main>

    <footer>
        <p>Volver al <a href="../index.html">Índice Principal</a></p>
    </footer>
</body>
</html>